/*++

 Copyright (c) 2006 Microsoft Corporation.  All rights reserved.

 The use and distribution terms for this software are contained in the file
 named license.rtf, which can be found in the root of this distribution.
 By using this software in any fashion, you are agreeing to be bound by the
 terms of this license.

 You must not remove this notice, or any other, from this software.

--*/

#ifndef COMINTERFACE__H_
#define COMINTERFACE__H_

// this is generated by sde\common\idl\DeviceEmulator to %_NTTREE%\inc\SmartDevices
// (aka SMARTDEVICE_PRIVATE_INC defined in sde\sources.inc)
#include "decominterfaces.h"

#if !FEATURE_COM_INTERFACE
// This file (along with vcecominterfaces.idl and vcecominterfaces_i.c) should be
// built only for emulators that support COM interop back to a host via
// IDeviceEmulatorVirtualMachineManager and IDeviceEmulatorVirtualMachineTransport.
#error FEATURE_COM_INTERFACE should be specified if this file is built
#endif //!FEATURE_COM_INTERFACE

class CEmulatorItem : public IDeviceEmulatorItem
{
public:
    CEmulatorItem();
    virtual ~CEmulatorItem();

    // IUnknown
    HRESULT __stdcall QueryInterface(REFIID	inInterfaceID,void** outInterface);
    ULONG __stdcall AddRef();
    ULONG __stdcall Release();

    // IOleItemContainer
     // IParseDisplayName
    virtual HRESULT STDMETHODCALLTYPE ParseDisplayName(
        IBindCtx * pbc,
        LPOLESTR pszDisplayName,
        ULONG * pchEaten,
        IMoniker ** ppmkOut
        );
     // IOleContainer
    virtual HRESULT STDMETHODCALLTYPE EnumObjects(
        DWORD grfFlags,
        IEnumUnknown **ppenum
        );
    virtual HRESULT STDMETHODCALLTYPE LockContainer(
        BOOL fLock  //Value indicating lock or unlock
        );
     // IOleItemContainer itself
    virtual HRESULT STDMETHODCALLTYPE GetObject(
        LPOLESTR pszItem,
        DWORD dwSpeedNeeded,
        IBindCtx * pbc,
        REFIID riid,
        void ** ppvObject
        );
    virtual HRESULT STDMETHODCALLTYPE GetObjectStorage(
        LPOLESTR pszItem,
        IBindCtx * pbc,
        REFIID riid,
        void ** ppvStorage
        );
    virtual HRESULT STDMETHODCALLTYPE IsRunning(
        LPOLESTR pszItem
        );

    // IDeviceEmulatorItem
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE BringVirtualMachineToFront(
        );
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ResetVirtualMachine(
        /* [in] */ boolean hardReset);
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ShutdownVirtualMachine(
        /* [in] */ boolean	saveMachine );
    virtual HRESULT STDMETHODCALLTYPE BindToDMAChannel(
        /* [in] */ ULONG dmaChannel,
        /* [out][retval] */ IDeviceEmulatorDMAChannel** ppDMAChannel);
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetVirtualMachineName(
        /* [out] */ LPOLESTR *virtualMachineName);
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetVirtualMachineName(
        /* [in] */ LPOLESTR virtualMachineName);

    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetMACAddressCount(
        /* [out, retval] */ ULONG* numberOfMACs );

    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE EnumerateMACAddresses(
        /* [in, out] */  ULONG* numberOfMacs,
        /* [out, size_is(*numberOfMacs*6)]*/ BYTE arrayOfMACAddresses[]);

    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ConfigureDevice(
        /* [in] */ HWND hwndParent,
        /* [in] */ LCID lcidParent,
        /* [in] */ BSTR bstrConfig,
        /* [out] */ BSTR* pbstrConfig);

    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDebuggerInterface( 
        /* [retval][out] */ IDeviceEmulatorDebugger **ppDebugger);

private:
    ULONG m_RefCount;
    CRITICAL_SECTION m_DMABindLock;
};

class DMAChannelRecord;
class AddressRecord;

class CEmulatorDMAChannel : public IDeviceEmulatorDMAChannel {
public:
    CEmulatorDMAChannel();
    virtual ~CEmulatorDMAChannel();

    // IUnknown
    HRESULT __stdcall QueryInterface(REFIID	inInterfaceID,void** outInterface);
    ULONG __stdcall AddRef();
    ULONG __stdcall Release();

    // IDeviceEmulatorDMAChannel
    virtual HRESULT STDMETHODCALLTYPE Send(
        /* [in, size_is(byteCount)] */ const BYTE* dataBuffer,
        /* [in] */ USHORT byteCount);
        
    virtual HRESULT STDMETHODCALLTYPE Receive(
        /* [out, size_is(*byteCount), length_is(*byteCount)] */ BYTE* dataBuffer,
        /* [in, out] */ USHORT* byteCount,
        /* [in] */ ULONG Timeout);
     
    // Enable re-use of CEmulatorDMAChannel
    ULONG getRefCount() { return m_RefCount; } 
    DMAChannelRecord * getRecord() { return m_Record; }
   
    void  AttachToChannelIndex( DMAChannelRecord * Record ); 

private:
    ULONG m_RefCount;
    DMAChannelRecord * m_Record;
};

#define BufferSizeDMA 0x1000
#define FirstChannel 4
#define NumberOfChannels 4
// Connectix uses a 64-element queue to hold these packets until
// the Win32 caller can retreive them.  Once the queue fills,
// Connectix drops the oldest packet and overwrites it with the
// newest.
//
// There are two DMATransportQueues for each open channel.  They are large (256k)
// so they're created on-demand, when a caller opens a channel.
typedef class DMATransportQueue {
public:
    DMATransportQueue();
    bool Enqueue(const BYTE *dataBuffer, USHORT byteCount, bool FailOnFull);
    bool Dequeue(BYTE *dataBuffer, unsigned __int32 *byteCount);
    bool IsEmpty(void);
    void Reset();

private:
    #define BufferCount 64
    BYTE Buffers[BufferSizeDMA*BufferCount];
    USHORT BufferSizes[BufferCount];
    int Head;
    int Tail;
} DMATransportQueue;

#define UNINITIALIZED_STATE 0
#define BLANK_STATE         1 
#define DESKTOP_CONNECTED   2
#define DEVICE_CONNECTED    4
#define ADDR_CONNECTED      8

typedef class DMAChannelRecord {
public:
    DMAChannelRecord();
    ~DMAChannelRecord();

    void AttachChannel( DWORD channelIndex, DWORD channelStatus );
    void DetachChannel( DWORD Status );
    void ResetChannel();
    bool InitializeChannel();

    // Accessors
    CEmulatorDMAChannel * getCEmulatorDMAChannel() {return m_EmulatorDMAChannel; }
    DMATransportQueue * getSendQueue() { return SendQueue; }
    DMATransportQueue * getReceiveQueue() {return ReceiveQueue; }
    unsigned __int32 getFlags() {return Flags;} 
    HANDLE getReceiveEvent() { return ReceiveEvent; } 
    unsigned __int32 getChannelIndex();
    bool isVirtual();
    AddressRecord * getCurrentRecord() { return Record; }

    bool isDesktopConnected() {return (ChannelState & DESKTOP_CONNECTED); }
    bool isDeviceConnected()  {return (ChannelState & DEVICE_CONNECTED); }
    bool isAddrConnected()  {return (ChannelState & ADDR_CONNECTED); }
    unsigned __int32 getChannelState() { return ChannelState; }

    // Mutators
    void setFlags( unsigned __int32 flags_new ) { Flags = flags_new; }
    void setChannelState( unsigned __int32 state_new ) { ChannelState = state_new; } 
    void setChannelIndex(DWORD channelIndex);
    void setCurrentRecord( AddressRecord * inRecord ) { Record = inRecord; }

private:
    CEmulatorDMAChannel *m_EmulatorDMAChannel;
    DMATransportQueue *SendQueue;
    DMATransportQueue *ReceiveQueue;
    unsigned __int32 Flags; // 0 means the channel does not have data to read, 1 means it does
    HANDLE ReceiveEvent;
    unsigned __int32 ChannelState;
    unsigned __int32 ChannelIndex;
    AddressRecord *  Record; // only set for channel connected to address service

    void ReleaseResources(bool ShutDown);

} DMAChannelRecord;


#define VIRT_CHANNEL_BASE 0x80000000
#define VIRT_CHANNEL_RESR 0x1000
#define NEW_VIRTUAL_CHANNEL 0x80000000
#define NEW_ADDR_CHANNEL 0x80000001
#define CHANNEL_ARRAY_SIZE          50
#define CHANNEL_LOOKUP_TABLE_SIZE   512

#define MinimumStateFileVersionForDMATransport 12

typedef class DMAChannelRecordSet {
public:
    DMAChannelRecordSet();
    ~DMAChannelRecordSet();

    void SaveState(StateFiler& filer) const;
    void RestoreState(StateFiler& filer);

    DMAChannelRecord * getChannel(DWORD ChannelNumber);
    DMAChannelRecord * createChannel(DWORD ChannelNumber, DWORD channelStatus);
    void deleteChannel(DWORD ChannelNumber);

    bool isChannelInUse( DWORD ChannelNumber, DWORD ChannelStatus );
    DWORD getUnusedChannelIndex(DWORD ChannelStatus);
    void disconnectAll(DWORD channelStatus);

private:
    struct ChannelArray {
        DMAChannelRecord Channels[CHANNEL_ARRAY_SIZE];
        ChannelArray * Next;
    };

    struct TableEntry {
        TableEntry()
        {
            channel = NULL;
            next    = NULL;
        }
        DMAChannelRecord * channel;
        TableEntry * next;
    };

    DMAChannelRecord * getBlankChannel();
    ChannelArray * growChannelArray();

    bool addToLookupTable( DMAChannelRecord * channel );
    bool removeFromLookupTable( DWORD ChannelNumber );
    DMAChannelRecord * lookupFromTable(DWORD ChannelNumber);
    unsigned __int32 calcTableIndex(DWORD ChannelNumber);

    // The channel records are stored in an dynamic array to minimize the storage
    // requirements and are lookup via hashtable for O(1) look up time.
    ChannelArray * ArrayList;
    TableEntry * LookupTable[CHANNEL_LOOKUP_TABLE_SIZE];
    // This is the last channel number we gave out so generally the numbers above it
    // are safe to hand out until we roll over
    unsigned __int32 UnusedDeviceChannel;
} DMAChannelRecordSet;

class AddressRecord {
public:
        AddressRecord()
        {
            idLength = 0;
            id = NULL;
            channel = 0;
            channelRecord = NULL;
            next = NULL;
        }
        ~AddressRecord()
        {
            if ( id != NULL)
                delete [] id;
        }
        unsigned __int16 ReadRecord(unsigned __int8 * buffer, unsigned int BufferSize, bool MultipleEntries);
        unsigned __int16 WriteRecord(unsigned __int8 * buffer, unsigned int BufferSize);

        unsigned __int32    idLength;
        unsigned __int8 *   id;
        unsigned __int32    channel;
        DMAChannelRecord *  channelRecord;
        AddressRecord *     next;
    };

class DMAAddressService {
public:
    DMAAddressService();
    ~DMAAddressService();

    void SaveState(StateFiler& filer);
    void RestoreState(StateFiler& filer);

    void connectChannel(DMAChannelRecord * channel);
    void disconnectChannel(DMAChannelRecord * channel);

    HRESULT readAddressChannel( DMAChannelRecord * channel, BYTE* inDataBuffer, USHORT* inByteCount );
    HRESULT writeAddressChannel( DMAChannelRecord * channel );

private:
    AddressRecord * Records;
    CRITICAL_SECTION AddressListAccess;
};

class IODMATransport : public MappedIODevice {
    friend class CEmulatorDMAChannel;

public:
    virtual bool __fastcall PowerOn(void);
    virtual bool __fastcall Reset(void);
    virtual void __fastcall SaveState(StateFiler& filer) const;
    virtual void __fastcall RestoreState(StateFiler& filer);

    virtual unsigned __int8 __fastcall ReadByte(unsigned __int32 IOAddress);
    virtual unsigned __int16 __fastcall ReadHalf(unsigned __int32 IOAddress);
    virtual unsigned __int32 __fastcall ReadWord(unsigned __int32 IOAddress);
    virtual void __fastcall WriteByte(unsigned __int32 IOAddress, unsigned __int8 Value);
    virtual void __fastcall WriteHalf(unsigned __int32 IOAddress, unsigned __int16 Value);
    virtual void __fastcall WriteWord(unsigned __int32 IOAddress, unsigned __int32 Value);

    // called by CEmulatorVirtuaTransport
    HRESULT __fastcall Send(DMAChannelRecord * channel, const BYTE *dataBuffer, USHORT byteCount);
    HRESULT __fastcall Receive(DMAChannelRecord * channel, BYTE *dataBuffer, USHORT *byteCount, ULONG Timeout);
    HRESULT BindToDMAChannel(
        /* [in] */ ULONG dmaChannel,
        /* [out][retval] */ IDeviceEmulatorDMAChannel** opDMAChannel);

private:
    void RaiseInterrupt(DWORD channelIndex);
    void ClearInterrupt(void);
    void UnbindFromDMAChannel(ULONG dmaChannelIndex);

    // Layout of the IO registers is as follows:
    // 0x0000: __int8 InputBuffer[0x1000]
    // 0x1000: __int8 OutputBuffer[0x1000]
    // 0x2000: __int32 Flags0
    // 0x2004: __int32 Flags1
    // 0x2008: __int32 Flags2
    // 0x200c: __int32 Flags3
    // 0x2010: __int32 InputDataLength
    // 0x2014: __int32 InputDataPtr
    // 0x2018: __int32 InputStatus
    // 0x201c: __int32 OutputDataLength
    // 0x2020: __int32 OutputDataPtr
    // 0x2024: __int32 OutputStatus
    // 0x2080: __int32 GlobalRegister0
    // 0x2084: __int32 FlagsRegister0 - holds a guest physical address of a UINT32... the address of Flags0
    // 0x2088: __int32 IOInputRegister0
    // 0x208c: __int32 IOOutputRegister0
    // 0x2090: __int32 IRQRegister0
    // 0x2094: __int32 IRQAcknowledgeRegister0
    // 0x2098: // Reserved0
    // 0x209c: // Reserved0
    // 0x20a0: __int32 GlobalRegister0
    // 0x20a4: __int32 FlagsRegister0 - holds a guest physical address of a UINT32... the address of Flags0
    // 0x20a8: __int32 IOInputRegister0
    // 0x20ac: __int32 IOOutputRegister0
    // 0x20b0: __int32 IRQRegister0
    // 0x20b4: __int32 IRQAcknowledgeRegister0
    // 0x20b8: // Reserved0
    // 0x20bc: // Reserved0
    // 0x20c0: __int32 GlobalRegister0
    // 0x20c4: __int32 FlagsRegister0 - holds a guest physical address of a UINT32... the address of Flags0
    // 0x20c8: __int32 IOInputRegister0
    // 0x20cc: __int32 IOOutputRegister0
    // 0x20c0: __int32 IRQRegister0
    // 0x20c4: __int32 IRQAcknowledgeRegister0
    // 0x20c8: // Reserved0
    // 0x20cc: // Reserved0
    // 0x20cc: // CurrentVirtualChannel
    // 0x20cc: // VirtualOperation
    // 0x20cc: // VirtualStatus
    #define InputDataOffset ((2*BufferSizeDMA)+(NumberOfChannels*sizeof(unsigned __int32)))
    #define DMAChannelOffset (InputDataOffset+6*sizeof(unsigned __int32))

    unsigned __int8 InputBuffer[BufferSizeDMA];
    unsigned __int8 OutputBuffer[BufferSizeDMA];
    unsigned __int32 Flags[NumberOfChannels];
    unsigned __int32 InputDataLength;
    unsigned __int32 InputDataPtr;
    unsigned __int32 InputStatus;
    unsigned __int32 OutputDataLength;
    unsigned __int32 OutputDataPtr;
    unsigned __int32 OutputStatus;

    typedef struct {
        unsigned __int32 GlobalRegister;
        unsigned __int32 FlagsRegister;
        unsigned __int32 IOInputRegister;
        unsigned __int32 IOOutputRegister;
        unsigned __int32 IRQRegister;
        unsigned __int32 IRQAcknowledgeRegister;
        unsigned __int32 Reserved0;
        unsigned __int32 Reserved1;
    } DMAChannel;

    DMAChannel DMAChannels[NumberOfChannels];
    unsigned __int32 CurrentVirtualChannel;
    #define DeviceAttachOperation   1
    #define DeviceDetachOperation  2
    #define IsChannelInUseOperation 4
    #define NewVirtChannelOperation 8
    #define NewAddrChannelOperation 16
    unsigned __int32 VirtualOperation;
    unsigned __int32 VirtualStatus;
    unsigned __int32 VirtualChannelIndexF;
    unsigned __int32 VirtualChannelIndexR;
    unsigned __int32 VirtualChannelIndexW;
    // end of variables that correspond to the WinCE DMA Transport device
};

HRESULT BindToVMID(const GUID* pVMID, IDeviceEmulatorItem** ppItem);


class CClassFactory : public IClassFactory {
public:
    CClassFactory();

    HRESULT __stdcall QueryInterface(REFIID	inInterfaceID,void** outInterface);
    ULONG __stdcall AddRef();
    ULONG __stdcall Release();

    virtual /* [local] */ HRESULT STDMETHODCALLTYPE CreateInstance(
        /* [unique][in] */ IUnknown *pUnkOuter,
        /* [in] */ REFIID riid,
        /* [iid_is][out] */ void **ppvObject) = 0;

    virtual /* [local] */ HRESULT STDMETHODCALLTYPE LockServer(
        /* [in] */ BOOL fLock);

private:
    ULONG m_RefCount;
};

class CClassFactoryDEVMM : public CClassFactory {
public:
    virtual /* [local] */ HRESULT STDMETHODCALLTYPE CreateInstance(
        /* [unique][in] */ IUnknown *pUnkOuter,
        /* [in] */ REFIID riid,
        /* [iid_is][out] */ void **ppvObject);
};

class CClassFactoryDEVT : public CClassFactory {
public:
    virtual /* [local] */ HRESULT STDMETHODCALLTYPE CreateInstance(
        /* [unique][in] */ IUnknown *pUnkOuter,
        /* [in] */ REFIID riid,
        /* [iid_is][out] */ void **ppvObject);
};

#endif //COMINTERFACE__H_H
